\subsection{C}

\begin{itemize}
\item{Les booléens sont représentés par des entiers. \texttt{false} est
      représenté par la valeur 0, tous les autres entiers sont équivalents
      à \texttt{true} ;}
\item{Les fonctions prenant des tableaux en paramètres prennent à la place
      de ce tableau deux paramètres : \texttt{type* tableau}, le tableau,
      et \texttt{size\_t size}, la taille du tableau ;}
\item{Les fonctions retournant des tableaux retournent à la place le type
      \texttt{void}, et prennent deux paramètres supplémentaires :
      \texttt{type** tableau} ou sera placé le tableau résultant (dont
      l'allocation n'est pas à votre charge), et \texttt{size\_t* size} ou
      sera placée la taille du tableau résultant. La libération du tableau
      est laissée au soin du candidat ;}
\item{Tout le reste est comme indiqué dans le sujet.}
\end{itemize}

\subsection{C++}

\begin{itemize}
\item{Les tableaux sont représentés par des \texttt{std::vector<type>} ;}
\item{Le reste est identique au sujet.}
\end{itemize}

\subsection{C\#}

\begin{itemize}
\item{Les fonctions à utiliser sont des méthodes statiques de la classe Api.
      Ainsi, pour utiliser la fonction \texttt{Foo}, il faut faire
      \texttt{Api.Foo} ;}
\item{Les noms des fonctions, structures et énumérations sont en
      \texttt{CamelCase}. Ainsi, une fonction nommée \texttt{foo\_bar} dans
      le sujet s'appellera \texttt{FooBar} en C\#.}
\end{itemize}

\subsection{Caml}

\begin{itemize}
\item{L'API est fournie par le fichier \texttt{api.ml}, qui est \texttt{open}
      par défaut par le fichier à compléter ;}
\item{Les énumérations sont représentées par des types sommes avec des
      constructeurs sans paramètres. Seule la première lettre des noms des
      constructeurs est en majuscule ;}
\item{Les structures sont représentées par des records, sauf pour la structure
      \texttt{position} qui est représentée par un couple \texttt{int * int} ;}
\item{Les tableaux sont représentés par des \texttt{array} Caml classiques.}
\end{itemize}

\subsection{Java}

\begin{itemize}
\item{Les fonctions à utiliser sont des méthodes statiques de la classe
      \texttt{Interface}. Ainsi, pour utiliser la fonction \texttt{foo}, il
      faut faire \texttt{Interface.foo} ;}
\item{Les structures sont représentées par des classes dont tous les attributs
      sont publics.}
\end{itemize}

\subsection{Pascal}

\begin{itemize}
\item{Tout ou presque est dans l'API, rien de spécial.}
\end{itemize}

\subsection{PHP}

\begin{itemize}
\item{Les constantes sont définies via des \texttt{define} et doivent donc être
      utilisées sans les précéder d'un signe dollar ;}
\item{Les énumérations sont définies comme des séries de constantes. Se référer
      à la puce au dessus ;}
\item{Les structures sont gérées sous forme de tableaux associatifs. Ainsi, une
      structure contenant un champ \texttt{x} et un champ \texttt{y} sera crée
      comme ceci : \texttt{array('x' => 42, 'y' => 1337)}.}
\end{itemize}

\subsection{Python}

\begin{itemize}
\item{L'API est fournie par le module \texttt{api}, dont tout le contenu est
      importé par défaut par le code à compléter ;}
\item{Les constantes des énumérations sont représentées par des entiers ;}
\item{Les structures sont représentés par des \texttt{namedtuple} Python, dont
      les champs peuvent être accèdés via la notation pointée habituelle, et
      qui peuvent être créés comme ceci : \texttt{foo(bar=42, x=3)}.}
\end{itemize}
