#!/usr/bin/env python
#-*- encoding: utf-8 -*-
"""
master_server.py
Stechec's master server.

Copyright (c) 2009 Pierre "delroth" Bourdon <delroth@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import codecs
import getopt
import MySQLdb
import os
import re
import select
import signal
import socket
import sys
import time
import traceback
import yaml

def struct(name, fields):
    fields = fields.split()
    class Foo(object):
        def __init__(self, **kwargs):
            li = [None for f in fields]
            for kw, v in kwargs.iteritems():
                if kw not in fields:
                    raise ValueError
                i = fields.index(kw)
                li[i] = v
            self.__dict__['__tuple'] = tuple(li)

        def __getattr__(self, name):
            if name not in fields:
                raise AttributeError
            i = fields.index(name)
            return self.__dict__['__tuple'][i]

        def __setattr__(self, name, val):
            if name not in fields:
                raise AttributeError
            i = fields.index(name)
            li = list(self.__dict__['__tuple'])
            li[i] = val
            self.__dict__['__tuple'] = tuple(li)

        def __hash__(self):
            return hash(self.__dict__['__tuple'])
    Foo.__name__ = name
    return Foo

SCORE_RE = re.compile(
    r'^(\d+) (\d+) (-?\d+) (.*)$'
)

ComputersConf = struct("ComputersConf",
    "cfg slots_available last_expire sockets sock_listen"
)
computers_conf = None

Computer = struct("Computer",
    "sock slots ip port srv_port last_heartbeat tmp_msg"
)
computers_list = []

MatchesConf = struct("MatchesConf",
    "last_expire last_poll nb_waiting"
)
matches_conf = None
matches = {}

CompilsConf = struct("CompilsConf",
    "last_poll nb_waiting"
)
compils_conf = None
compils_list = []

rctl_socket = None
db = None

def log(module, message):
    print '[%s] %s' % (module, message)

def execute_query(q, tup=()):
    cursor = db.cursor()
    cursor.execute(q, tup)
    return cursor

def init_computer_pool(cfg):
    global computers_conf

    computers_conf = ComputersConf(
        cfg=cfg,
        slots_available=0,
        last_expire=time.time(),
        sockets=[],
        sock_listen=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    )
    computers_conf.sock_listen.setsockopt(
        socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    computers_conf.sock_listen.bind(('0.0.0.0', cfg.get('listen_port', 3917)))
    computers_conf.sock_listen.listen(10)
    computers_conf.sockets.append(computers_conf.sock_listen)

    log('computer', 'init ok')

def accept_computer():
    sock, (host, port) = computers_conf.sock_listen.accept()
    log('computer', 'connection from %s:%d' % (host, port))
    comp = Computer(
        sock=sock,
        ip=host,
        port=port,
        srv_port=computers_conf.cfg['server_port_range_begin'],
        slots=computers_conf.cfg['max_process'],
        last_heartbeat=time.time(),
        tmp_msg=''
    )
    computers_conf.sockets.append(sock)
    computers_list.append(comp)

def kill_computer(comp):
    log('computer', 'killing %s:%d' % (comp.ip, comp.port))
    computers_list.remove(comp)
    computers_conf.sockets.remove(comp.sock)
    comp.sock.close()
    computers_conf.slots_available -= computers_conf.cfg['max_process'] - comp.slots

def heartbeat_from_computer(comp, args):
    comp.last_heartbeat = time.time()

    args.reverse()
    while len(args) != 0:
        if args.pop() == "slots":
            slots = int(args.pop())
            computers_conf.slots_available += comp.slots - slots
            comp.slots = slots
            log('computer', 'ping from %s:%d, slots used : %d, total : %d' % (
                comp.ip, comp.port ,comp.slots, computers_conf.slots_available))

def computer_periodic():
    global computers_conf

    now = time.time()
    if now < computers_conf.last_expire + 5:
        return

    log("computer", "check expire: %d running computer" % len(computers_list))
    for comp in computers_list:
        if now > comp.last_heartbeat + computers_conf.cfg['heartbeat_timeout'] + 10:
            log("computer", "%s:%d expired" % (comp.ip, comp.port))
            kill_computer(comp)
    computers_conf.last_expire = now

def reserve_slot():
    comps = list(sorted(computers_list, key=lambda c: c.slots))
    comp = comps[0]
    comp.slots += 1
    computers_conf.slots_available -= 1
    return comp

def init_match_pool():
    global matches_conf

    matches_conf = MatchesConf(
        last_expire=time.time(),
        last_poll=time.time(),
        nb_waiting=0
    )

    execute_query('UPDATE stechec_match SET statut=1 WHERE statut=2')
    log('match', 'init ok')

def matches_periodic():
    return

def match_start_server(server, mid, mapid):
    srv_port = server.srv_port + 1
    if srv_port > computers_conf.cfg['server_port_range_end']:
        srv_port = computers_conf.cfg['server_port_range_begin']
    server.srv_port = srv_port
    return send_message(server, "server %d toons  0 %d 2 %d 2 -- --" % (
        mid, mid, srv_port))

def match_start_client(comp, id, server, coid, chid, usid, tid):
    return send_message(server, "client %d toons  0 %d %d %d %d %d %d %s" % (
        id, usid, chid, coid, tid, id, server.srv_port, server.ip))

def match_start(id, map_id):
    if computers_conf.slots_available < 3:
        log('match', 'not enough slots available')
        return -1

    execute_query('UPDATE stechec_match SET statut=2 WHERE id=%s', (id,))

    cur = execute_query('SELECT stechec_competiteur.id AS coid, stechec_champion.id AS chid, stechec_champion.auteur_id AS auid FROM stechec_competiteur '
                        'LEFT JOIN stechec_champion ON stechec_competiteur.champion_id = stechec_champion.id WHERE stechec_competiteur.match_id=%s ORDER BY stechec_competiteur.id', (id,))
    results = cur.fetchall()
    if len(results) != 2:
        log('match', 'not enough or too much competiteurs')
        execute_query('UPDATE stechec_match SET statut=4 WHERE id=%s', (id,))
        return 0

    matches[id] = []
    server = reserve_slot()
    matches[id].append(server)

    err = match_start_server(server, id, map_id)
    if err:
        log('match', 'unable to launch server')
        execute_query('UPDATE stechec_match SET statut=1 WHERE id=%s', (id,))
        return -1

    for i, (coid, chid, auid) in enumerate(results):
        comp = reserve_slot()
        err = match_start_client(comp, id, server, coid, chid, auid, i)
        if err:
            log('match', 'unable to launch client')
            execute_query('UPDATE stechec_match SET statut=1 WHERE id=%s', (id,))
            return -1
    
    return 0

def dispatch_server_result(server, args):
    id, exit_status, args = args[0], args[1], args[2:]
    logs = ' '.join(args)
    if logs != '':
        logs = logs.split('\n')[1:-1]
    if int(exit_status) != 0:
        log('match', 'id=%s failed (status=%s)' % (id, exit_status))
    else:
        log('match', 'id=%s done (status=%s)' % (id, exit_status))
    execute_query("UPDATE stechec_match SET statut=3 WHERE id=%s",
            (id,))

    cur = execute_query('SELECT id FROM stechec_competiteur WHERE match_id=%s ORDER BY id', (id,))
    results = cur.fetchall()
    scores = []
    for line in logs:
        mobj = SCORE_RE.match(line)
        if mobj is not None:
            idp, score, fail, l = mobj.groups()
            if fail != -1:
                score = -1
            scores.append((score, results[int(idp)][0]))

    cur = db.cursor()
    cur.executemany('UPDATE stechec_competiteur SET score = %s WHERE id = %s', scores)

def dispatch_client_result(client, args):
    return

def match_pool_poll():
    if time.time() < matches_conf.last_poll + 1:
        return

    matches_conf.last_poll = time.time()

    cur = execute_query("SELECT id, map_id FROM stechec_match WHERE statut=1")
    results = cur.fetchall()

    matches_conf.nb_waiting = len(results)
    for (id, map_id) in results:
        id, map_id = int(id), int(map_id) if map_id is not None else map_id
        log('match', 'started match %d' % id)
        if match_start(id, map_id) == -1:
            break
        matches_conf.nb_waiting -= 1

def init_compil_pool():
    global compils_conf

    compils_conf = CompilsConf(
        last_poll=time.time(),
        nb_waiting=0,
    )
    execute_query('UPDATE stechec_champion SET statut=0 WHERE statut=1')
    log('compilation', 'init ok')

def compilations_periodic():
    return

def compilation_start(id, auteur):
    if computers_conf.slots_available < 1:
        log('compilation', 'no more slots available')
        return -1
    execute_query("UPDATE stechec_champion SET statut=1 WHERE id=%s", (id,))

    err = send_message(reserve_slot(), 'compil %d  %d %d' % (id, auteur, id))
    if err:
        execute_query("UPDATE stechec_champion SET statut=0 WHERE id=%s", (id,))
    return 0

def compilation_pool_poll():
    if time.time() < compils_conf.last_poll + 1:
        return

    compils_conf.last_poll = time.time()

    cur = execute_query("SELECT id, auteur_id FROM stechec_champion WHERE statut=0")
    results = cur.fetchall()

    compils_conf.nb_waiting = len(results)
    for (id, auteur_id) in results:
        id, auteur_id = int(id), int(auteur_id)
        log('compilation', 'started champion %d (from author %d)' % (id, auteur_id))
        if compilation_start(id, auteur_id) == -1:
            break
        compils_conf.nb_waiting -= 1

def dispatch_compil_result(comp, args):
    id, exit_status = args[0], args[1]
    if int(exit_status) != 0:
        log('compilation', 'id=%s failed (status=%s)' % (id, exit_status))
        st = 3
    else:
        log('compilation', 'id=%s done (status=%s)' % (id, exit_status))
        st = 2
    execute_query("UPDATE stechec_champion SET statut=%s WHERE id=%s",
            (st, id))

def init_remote_control():
    global rctl_socket

    rctl_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    rctl_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    rctl_socket.bind(('0.0.0.0', 3939))
    rctl_socket.listen(10)

    computers_conf.sockets.append(rctl_socket)
    log('rctl', 'init ok')

def answer_machine_command(sock, arg):
    if arg == "list":
        for comp in computers_list:
            usage = comp.slots * 100 / computers_conf.cfg['max_process']
            sock.send('%s %d 1 %d %d %d\n' % (
                comp.ip, comp.port, comp.last_heartbeat,
                comp.slots, usage))
    elif arg == "summary":
        sock.send('%d %d %d\n' % (len(computers_list),
            computers_conf.cfg['max_process'],
            computers_conf.slots_available))
    else:
        log('rctl', 'machine: unknown arg %s' % arg)

def answer_remote_control():
    cmds = {'machine': answer_machine_command}
    sock, addr = rctl_socket.accept()
    msg = sock.recv(64)
    log("rctl", "command received: %s" % msg)
    items = msg.split()
    cmd, arg = items[0], items[1]
    if cmd in cmds:
        cmds[cmd](sock, arg)
    sock.close()

def receive_message(comp):
    msg = comp.sock.recv(1024)
    if msg == '':
        log('computer', 'connection lost')
        kill_computer(comp)
        return
    msg = comp.tmp_msg + msg
    lines = [l for l in msg.split('\n.\n') if l]
    comp.tmp_msg = ''
    if not msg.endswith('.\n'):
        comp.tmp_msg = lines.pop()
    
    for line in lines:
        command, args = line.split(' ')[0], line.split(' ')[1:]
        if command == "ping":
            heartbeat_from_computer(comp, args)
        elif command == "result":
            comp.last_heartbeat = time.time()
            if args[0] == 'compil':
                dispatch_compil_result(comp, args[1:])
            elif args[0] == 'server':
                dispatch_server_result(comp, args[1:])
            elif args[0] == 'client':
                dispatch_client_result(comp, args[1:])
            else:
                log('computer', 'unknown result received %s' % args[0])
        else:
            log('computer', 'unknown message %s' % command)

def send_message(comp, msg):
    try:
        comp.sock.send(msg + '\n', socket.MSG_DONTWAIT)
    except socket.error:
        log('computer', 'connection lost')
        kill_computer(comp)
        return True
    return False

loop = True

def stop_loop(a1, a2):
    global loop
    loop = False

def connect_to_database(cfg):
    global db

    db = MySQLdb.connect(
            host=cfg['database']['ip'],
            port=cfg['database']['port'],
            db=cfg['database']['database'],
            user=cfg['database']['login'],
            passwd=cfg['database']['pass']
        )

def disconnect_database():
    global db
    db.close()

def main():
    global computers_conf
    global loop

    opts, args = getopt.getopt(sys.argv[1:], 'c:')
    cfg = opts[-1][1] if len(opts) != 0 else 'stechec.yml'
    cfg = yaml.load(codecs.open(cfg, encoding='iso-8859-15'))

    connect_to_database(cfg)

    signal.signal(signal.SIGINT, stop_loop)
    signal.signal(signal.SIGTERM, stop_loop)
    signal.signal(signal.SIGPIPE, signal.SIG_IGN)

    init_computer_pool(cfg['main_server'])
    init_match_pool()
    init_compil_pool()
    init_remote_control()
    
    sleep_time = cfg['main_server'].get('wait_sleep', 5)
    while loop:
        try:
            socks = computers_conf.sockets
            r, w, x = select.select(socks, [], [], sleep_time)
            for sock in r:
                fd = sock.fileno()
                if computers_conf.sock_listen.fileno() == fd:
                    accept_computer()
                elif rctl_socket.fileno() == fd:
                    answer_remote_control()
                else:
                    comp = filter(lambda c: c.sock.fileno() == fd, computers_list)[0]
                    receive_message(comp)
            computer_periodic()
            matches_periodic()
            compilations_periodic()
            match_pool_poll()
            compilation_pool_poll()
        except KeyboardInterrupt:
            loop = False
        except:
            log('main', 'An error happened, traceback below')
            traceback.print_exc()

    disconnect_database()
    log('main', 'exiting')
    
    return 0

if __name__ == '__main__':
    sys.exit(main())
