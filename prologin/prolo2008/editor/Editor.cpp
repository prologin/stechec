// Editor.cpp -- The Prologin 2008 Map Editor

#include <iostream>
#include <SDL.h>
#include <ctype.h>
#include <fstream>
#include <unistd.h>
#include "Gui.hpp"
#include "SpriteMgr.hpp"
#include "Editor.hpp"

// The map is stored as a simple double-array of characters.
// They are stored line by line in memory, i.e. you use g_map[y][x]
// to access (x,y).
static char		**gl_map = NULL;
static unsigned int	gl_xsize = 0;
static unsigned int	gl_ysize = 0;

// The currently selected case
static unsigned int	gl_curx = 0;
static unsigned int	gl_cury = 0;

// The filename of the file we are editing
static const char	*gl_filename = NULL;

static Gui		*gl_gui = NULL;
static SpriteMgr	*gl_mgr = NULL;

static bool		gl_grid = true;

// Each sprite is represented as an ASCII character in the file.
static CaseType	g_types[] =
{
  {MAP_ROBOT_TEAM1, INSTALL_PREFIX "r.png"},
  {MAP_ROBOT_TEAM2, INSTALL_PREFIX "R.png"},
  {MAP_HOLE, INSTALL_PREFIX "trou.png"},
  {MAP_WALL, INSTALL_PREFIX "mur.png"},
  {MAP_BALL, INSTALL_PREFIX "balle.png"},
  {MAP_EMPTY, INSTALL_PREFIX "ground.png"},
  {0, NULL}
};

// Initializes sprites from given images.
static void	InitSprites(void)
{
  unsigned int	i;
  
  for (i = 0; g_types[i]._c; ++i)
    gl_mgr->AddSprite(g_types[i]._c, g_types[i]._spath);
}

// Parses the map size given in `sizes'. The expected format is "XxY", e.g. "10x5".
// If either no sizes or invalid sizes are given, the default one are used.
// See Editor.hpp.
static void	GetMapSize(const char *sizes)
{
  char		*s;

  if (sizes && (s = strchr(sizes, 'x')))
  {
    *(s++) = '\0';
    gl_xsize = atoi(sizes);
    gl_ysize = atoi(s);
    if (gl_xsize > MAP_MAX_X || gl_ysize > MAP_MAX_Y || !(gl_xsize && gl_ysize))
      std::cerr << "Invalid size.  Using default values." << std::endl;
    else
      return ;
  }
  gl_xsize = DEFAULT_XSIZE;
  gl_ysize = DEFAULT_YSIZE;
}

// Initializes an empty map, filled by standar ground.
static void	InitEmptyMap(void)
{
  unsigned int	i;

  std::cout << "Initializing an empty map [" << gl_xsize << ',' << gl_ysize << ']' << std::endl;
  gl_map = new char*[gl_ysize];
  for (i = 0; i < gl_ysize; ++i)
  {
    gl_map[i] = new char[gl_xsize];
    memset(gl_map[i], MAP_EMPTY, gl_xsize);
  }
}

// Writes the current map to the file pointed to by `gl_filename'.
static void	WriteMapToFile(void)
{
  std::ofstream	f;
  unsigned int	i;
  unsigned int	j;

  std::cout << "Writing map to file '" << gl_filename << "'" << std::endl;
  f.open(gl_filename, std::ios::trunc);
  if (!f.is_open())
  {
    std::cerr << "Unable to open " << gl_filename << std::endl;
    return ;
  }
  f << "# Generated by the map editor\n";
  f << gl_xsize << ' ' << gl_ysize << '\n';
  for (i = 0; i < gl_ysize; ++i)
  {
    for (j = 0; j < gl_xsize; ++j)
      f << gl_map[i][j];
    f << '\n';
  }
  f.close();
}

// Render the map on-screen.
static void	RenderMap(void)
{
  unsigned int	x;
  unsigned int	y;

  gl_gui->Clear();
  for (y = 0; y < gl_ysize; ++y)
    for (x = 0; x < gl_xsize; ++x)
    {
      // Always draw a ground under the actual sprite.  Looks better.
      if (gl_map[y][x] != MAP_EMPTY)
	gl_gui->PutSprite(x * GRID_SIZE, y * GRID_SIZE, gl_mgr->GetSprite(MAP_EMPTY));
      gl_gui->PutSprite(x * GRID_SIZE, y * GRID_SIZE, gl_mgr->GetSprite(gl_map[y][x]));
    }

  if (gl_grid)
  {
    // Draws the grid *over* the sprites
    for (x = 0; x < gl_xsize; ++x)
      gl_gui->DrawRect(x * GRID_SIZE - 1, 0U, 0, gl_gui->GetYSize() - 1, 0);
    for (y = 0; y < gl_ysize; ++y)
      gl_gui->DrawRect(0U, y * GRID_SIZE - 1, gl_gui->GetXSize() - 1, 0, 0);
  }

  gl_gui->DrawRect(gl_curx * GRID_SIZE, gl_cury * GRID_SIZE,
       GRID_SIZE - 1, GRID_SIZE - 1, RECT_COLOR);
  gl_gui->Refresh();
}

static int	InitMapFromFile(void)
{
  std::ifstream	f;
  std::string	s;
  unsigned int	i;
  
  f.open(gl_filename);
  if (!f.is_open())
  {
    std::cerr << "Unable to open " << gl_filename << std::endl;
    return (1);
  }

  // Discards comments
  while (f.peek() == '#')
    getline(f, s);

  if (!(f >> gl_xsize >> gl_ysize))
  {
    std::cerr << "Invalid map (error reading map's size)." << std::endl;
    return (1);
  }

  if (gl_xsize > MAP_MAX_X || gl_ysize > MAP_MAX_Y)
  {
    std::cerr << "Invalid sizes. Go fix your map." << std::endl;
    return (1);
  }

  while (f.peek() != '\n')
    f.ignore();
  f.ignore();

  gl_map = new char*[gl_ysize];

  for (i = 0; i < gl_ysize; ++i)
    gl_map[i] = new char[gl_xsize];

  for (i = 0; i < gl_ysize; ++i)
  {
    getline(f, s);
    if (!f || s.size() != gl_xsize)
    {
      std::cerr << "Invalid map (missing line or column)" << std::endl;
      return (1);
    }
    memcpy(gl_map[i], s.c_str(), gl_xsize);
  }
  f.close();
  return (0);
}

// Performs a symetry on the map.
// If `up_to_down' is true, the upper part of the map
// is copied to the half bottom.
static void	MakeSymMap(bool up_to_down)
{
  unsigned int	y;
  unsigned int	x;
  unsigned int	newy;

  for (y = up_to_down ? 0 : gl_ysize - 1; y != gl_ysize / 2 - (up_to_down ? 0 : 1); y += up_to_down ? 1 : -1)
  {
    for (x = 0; x < gl_xsize; ++x)
    {
      newy = (gl_ysize - 1) - y;

      switch (gl_map[y][x])
      {
	case MAP_ROBOT_TEAM1:
	  gl_map[newy][x] = MAP_ROBOT_TEAM2;
	  break;

	case MAP_ROBOT_TEAM2:
	  gl_map[newy][x] = MAP_ROBOT_TEAM1;
	  break;

	case MAP_EMPTY:
	case MAP_WALL:
	case MAP_BALL:
	case MAP_HOLE:
	  gl_map[newy][x] = gl_map[y][x];
	  break;
	default:
	  std::cerr << "Internal error -- invalid character in map..." << std::endl;
      }
    }
  }
}

static void	ParseCmdLine(int argc, char *argv[])
{
  int		ch;
  int		cflag = 0;

  GetMapSize(NULL); // Initializes default values

  while ((ch = getopt(argc, argv, "cg:f:")) != -1)
  {
    switch (ch)
    {
      case 'c':
	cflag = 1;
	break;
      case 'f':
	gl_filename = optarg;
	break;
      case 'g':
	GetMapSize(optarg);
	break;
      default:
	std::cerr << USAGE << std::endl;
    }
  }

  argc -= optind;
  argv += optind;

  // If there's still arguments on the command line, we assume this is the filename.
  // Actually, as i'm too lazy to type '-f' each time, it helps. ;o)
  if (argv[0])
    gl_filename = argv[0];

  // If either:
  //   - we are creating a new map with '-c'
  //   - no filename has been providen (so no map to load)
  // we create an empty map.
  if (cflag || !gl_filename)
    InitEmptyMap();
  else
  {
    if (InitMapFromFile())
      InitEmptyMap();
  }

  if (!gl_filename)
    gl_filename = DEFAULT_FILENAME;
  std::cout << "Map file is " << gl_filename << std::endl;
}

static void	MouseButtonHandler(SDL_Event *e)
{
  gl_curx = e->button.x / GRID_SIZE;
  gl_cury = e->button.y / GRID_SIZE;
  RenderMap();
}

static void	KeyPressHandler(SDL_Event *e)
{
  SDLKey	sym;

  sym = e->key.keysym.sym;

  // Ctrl-W
  if (e->key.keysym.mod & KMOD_LCTRL)
  {
    if (sym == SDLK_w)
    {
      WriteMapToFile();
      return ;
    }
    if (sym == SDLK_UP || sym == SDLK_DOWN)
    {
      MakeSymMap(sym == SDLK_DOWN);
      RenderMap();
      return ;
    }
    if (sym == SDLK_g)
      gl_grid = !gl_grid;
  }

  // Arrows
  if (sym == SDLK_LEFT && gl_curx > 0)
    gl_curx--;
  else if (sym == SDLK_RIGHT && gl_curx < gl_xsize - 1)
    gl_curx++;
  else if (sym == SDLK_UP && gl_cury > 0)
    gl_cury--;
  else if (sym == SDLK_DOWN && gl_cury < gl_ysize - 1)
    gl_cury++;

  if (isalnum(sym) || ispunct(sym))
  {
    if (e->key.keysym.mod & KMOD_LSHIFT || e->key.keysym.mod & KMOD_RSHIFT)
      sym = (SDLKey)toupper(sym);
    if (gl_mgr->GetSprite(sym))
      gl_map[gl_cury][gl_curx] = sym;
  }

  RenderMap();
}

int	main(int argc, char *argv[])
{
  if (argc == 1)
  {
    std::cout << argv[0] << ": " <<
      "usage: " << argv[0] << " [-c] [-g WxH] [-f filename]\n" <<
      " -c:       Lance l'editeur avec une map vide\n" <<
      " -g:       Permet de definir la taille de la map\n" <<
      " -f:	  Specifie le nom du fichier a utiliser\n" <<
      "\nKeys:\n" <<
      "h/H        Hamster (equipe 1 ou 2)\n" <<
      "O          Trou\n" <<
      "P          Pomme\n" <<
      "X          Mur\n" <<
      "Arrows	  Deplace le selecteur de case (la souris marche aussi)\n" <<
      "Ctrl-W     Sauvegarde la map\n" <<
      "Ctrl-Up    Execute une symetrie du haut de la map vers le bas\n" <<
      "Ctrl-Down  Idem, du bas vers le haut\n" <<
      "Ctrl-g     Affiche/masque la grille\n" <<
      "\nBug report: deather@prologin.org" << std::endl;
    return (1);
  }

  try
  {
    gl_mgr = new SpriteMgr();

    InitSprites();
    ParseCmdLine(argc, argv);

    gl_gui = new Gui(gl_xsize * GRID_SIZE, gl_ysize * GRID_SIZE);

    gl_gui->SetCallback(SDL_KEYUP, KeyPressHandler);
    gl_gui->SetCallback(SDL_MOUSEBUTTONUP, MouseButtonHandler);

    RenderMap();
    gl_gui->Refresh();

    gl_gui->Loop();

    delete gl_mgr;
    delete gl_gui;
  }
  catch (std::string err)
  {
    std::cerr << err << std::endl;
    return (1);
  }
  return (0);
}
