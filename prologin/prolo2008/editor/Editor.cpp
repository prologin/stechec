// Editor.cpp -- The Prologin 2008 Map Editor

#include <iostream>
#include <SDL.h>
#include <ctype.h>
#include <fstream>
#include <unistd.h>
#include "Gui.hpp"
#include "SpriteMgr.hpp"
#include "Editor.hpp"

// The map is stored as a simple double-array of characters.
// They are stored line by line in memory, i.e. you use g_map[y][x]
// to access (x,y).
static char		**gl_map = NULL;
static unsigned int	gl_xsize = 0;
static unsigned int	gl_ysize = 0;

// The currently selected case
static unsigned int	gl_curx = 0;
static unsigned int	gl_cury = 0;

// The filename of the file we are editing
static const char	*gl_filename = NULL;

static Gui		*gl_gui = NULL;
static SpriteMgr	*gl_mgr = NULL;

// Each sprite is represented as an ASCII character in the file.
static CaseType	g_types[] =
{
  {'r', "sprites/r.png"},
  {'R', "sprites/R.png"},
  {'O', "sprites/trou.png"},
  {'X', "sprites/mur.png"},
  {'B', "sprites/balle.png"},
  {'.', "sprites/ground.png"},
  {0, NULL}
};

// Initializes sprites from given images.
static void	InitSprites(void)
{
  unsigned int	i;
  
  for (i = 0; g_types[i]._c; ++i)
    gl_mgr->AddSprite(g_types[i]._c, g_types[i]._spath);
}

// Parses the map size given in `sizes'. The expected format is "XxY", e.g. "10x5".
// If either no sizes or invalid sizes are given, the default one are used.
// See Editor.hpp.
static void	GetMapSize(const char *sizes)
{
  char		*s;

  if (sizes && (s = strchr(sizes, 'x')))
  {
    *(s++) = '\0';
    gl_xsize = atoi(sizes);
    gl_ysize = atoi(s);
    if (gl_xsize && gl_ysize)
      return ;
    // else: use default values
  }
  gl_xsize = DEFAULT_XSIZE;
  gl_ysize = DEFAULT_YSIZE;
}

// Initializes an empty map, filled by standar ground.
static void	InitEmptyMap(void)
{
  unsigned int	i;

  std::cout << "Initializing an empty map [" << gl_xsize << ',' << gl_ysize << ']' << std::endl;
  gl_map = new char*[gl_ysize];
  for (i = 0; i < gl_ysize; ++i)
  {
    gl_map[i] = new char[gl_xsize];
    memset(gl_map[i], GROUND_CHAR, gl_xsize);
  }
}

// Writes the current map to the file pointed to by `gl_filename'.
static void	WriteMapToFile(void)
{
  std::ofstream	f;
  unsigned int	i;
  unsigned int	j;

  std::cout << "Writing map to file '" << gl_filename << "'" << std::endl;
  f.open(gl_filename, std::ios::trunc);
  if (!f.is_open())
  {
    std::cerr << "Unable to open " << gl_filename << std::endl;
    return ;
  }
  f << "# Generated by the map editor\n";
  f << gl_xsize << ' ' << gl_ysize << '\n';
  for (i = 0; i < gl_ysize; ++i)
  {
    for (j = 0; j < gl_xsize; ++j)
      f << gl_map[i][j];
    f << '\n';
  }
  f.close();
}

// Render the map on-screen.
static void	RenderMap(void)
{
  unsigned int	x;
  unsigned int	y;

  gl_gui->Clear();
  for (y = 0; y < gl_ysize; ++y)
    for (x = 0; x < gl_xsize; ++x)
    {
      // Always draw a ground under the actual sprite.  Looks better.
      if (gl_map[y][x] != GROUND_CHAR)
	gl_gui->PutSprite(x * GRID_SIZE, y * GRID_SIZE, gl_mgr->GetSprite(GROUND_CHAR));
      gl_gui->PutSprite(x * GRID_SIZE, y * GRID_SIZE, gl_mgr->GetSprite(gl_map[y][x]));
    }
  gl_gui->DrawRect(gl_curx * GRID_SIZE, gl_cury * GRID_SIZE,
       GRID_SIZE - 1, GRID_SIZE - 1, RECT_COLOR);
  gl_gui->Refresh();
}

static int	InitMapFromFile(void)
{
  std::ifstream	f;
  std::string	s;
  unsigned int	i;
  
  f.open(gl_filename);
  if (!f.is_open())
  {
    std::cerr << "Unable to open " << gl_filename << std::endl;
    return (1);
  }

  // Discards comments
  while (f.peek() == '#')
    getline(f, s);

  if (!(f >> gl_xsize >> gl_ysize))
  {
    std::cerr << "Invalid map (error reading map's size)." << std::endl;
    return (1);
  }

  if (gl_xsize > MAP_MAX_X || gl_ysize > MAP_MAX_Y)
  {
    std::cerr << "Invalid sizes. Go fix your map." << std::endl;
    return (1);
  }

  while (f.peek() != '\n')
    f.ignore();
  f.ignore();

  gl_map = new char*[gl_ysize];

  for (i = 0; i < gl_ysize; ++i)
    gl_map[i] = new char[gl_xsize];

  for (i = 0; i < gl_ysize; ++i)
  {
    getline(f, s);
    if (!f || s.size() != gl_xsize)
    {
      std::cerr << "Invalid map (missing line or column)" << std::endl;
      return (1);
    }
    memcpy(gl_map[i], s.c_str(), gl_xsize);
  }
  f.close();
  return (0);
}

static void	ParseCmdLine(int argc, char *argv[])
{
  int		ch;
  int		cflag = 0;

  GetMapSize(NULL); // Initializes default values

  while ((ch = getopt(argc, argv, "cg:f:")) != -1)
  {
    switch (ch)
    {
      case 'c':
	cflag = 1;
	break;
      case 'f':
	gl_filename = optarg;
	break;
      case 'g':
	GetMapSize(optarg);
	break;
      default:
	std::cerr << USAGE << std::endl;
    }
  }

  argc -= optind;
  argv += optind;

  // If there's still arguments on the command line, we assume this is the filename.
  // Actually, as i'm too lazy to type '-f' each time, it helps. ;o)
  if (argv[0])
    gl_filename = argv[0];

  // If either:
  //   - we are creating a new map with '-c'
  //   - no filename has been providen (so no map to load)
  // we create an empty map.
  if (cflag || !gl_filename)
    InitEmptyMap();
  else
  {
    if (InitMapFromFile())
      InitEmptyMap();
  }

  if (!gl_filename)
    gl_filename = DEFAULT_FILENAME;
  std::cout << "Map file is " << gl_filename << std::endl;
}

static void	MouseButtonHandler(SDL_Event *e)
{
  gl_curx = e->button.x / GRID_SIZE;
  gl_cury = e->button.y / GRID_SIZE;
  RenderMap();
}

static void	KeyPressHandler(SDL_Event *e)
{
  char		sym;

  sym = e->key.keysym.sym;
  if (e->key.keysym.mod & KMOD_LCTRL && sym == SDLK_w)
  {
    WriteMapToFile();
    return ;
  }
  if (!isalnum(sym) && !ispunct(sym))
    return ;
  if (e->key.keysym.mod & KMOD_LSHIFT || e->key.keysym.mod & KMOD_RSHIFT)
   sym = toupper(sym);
  if (gl_mgr->GetSprite(sym))
    gl_map[gl_cury][gl_curx] = sym;
  RenderMap();
}

int	main(int argc, char *argv[])
{
  try
  {
    gl_mgr = new SpriteMgr();

    InitSprites();
    ParseCmdLine(argc, argv);

    gl_gui = new Gui(gl_xsize * GRID_SIZE, gl_ysize * GRID_SIZE);

    gl_gui->SetCallback(SDL_KEYUP, KeyPressHandler);
    gl_gui->SetCallback(SDL_MOUSEBUTTONUP, MouseButtonHandler);

    RenderMap();
    gl_gui->Refresh();

    gl_gui->Loop();

    delete gl_mgr;
    delete gl_gui;
  }
  catch (std::string err)
  {
    std::cerr << err << std::endl;
    return (1);
  }
  return (0);
}
